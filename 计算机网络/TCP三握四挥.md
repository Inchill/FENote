### TCP三次握手

- **第一次握手**

客户端向服务端发送一个请求连接报文段，将首部中同步位SYN置为1，将初始序号seq置为x，其中x是随机产生的。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。此时客户端进入SYN-SENT(同步已发送)状态。

- **第二次握手**

服务端收到请求连接报文段后，如果同意建立连接，则向客户端发送确认。在确认报文段中，应把SYN位和ACK位都置为1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段仍然不能携带数据，但同样要消耗掉一个序号。此时服务端进入SYN-RCVD(同步已收到)状态。

- **第三次握手**

客户端收到服务端的确认后，也要向服务端发送确认。确认报文段的ACK = 1，确认号ack = y + 1，自己的序号seq = x + 1.此时ACK报文段就可以携带数据了，不携带数据不会消耗序号，所以下一个报文段的序号仍然是seq = x + 1。此时客户端进入ESTABLISHED(已建立连接)状态。


### 为什么不能两次握手？

主要是为了防止已失效的请求连接报文段失效后服务端又接收到，此时服务端发送了确认报文段，陷入忙等状态，这样会消耗一个服务端资源。

### 为什么不四次握手？

在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。


***********

### TCP四次挥手

TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

- **第一次挥手**

客户端发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。此时报文段首部FIN = 1，序号seq = u(等于前面以传送过的数据的最后一个字节的序号加1).此时服务端进入FIN-WAIT-1(终止等待1)状态。
请注意：TCP规定，FIN报文段即使不携带数据，也要消耗掉一个序号。

- **第二次挥手**

服务端收到报文段后立即发出确认，确认号ack = u + 1，而自己的序号是v(等于前面以传送过的数据的最后一个字节的序号加1)，然后进入CLOSE-WAIT(关闭等待)状态。

- **第三次挥手**

若服务端已经没有要向服务端发送的数据，其应用进程就通知TCP释放连接。此时服务端发送的连接释放报文段必须使FIN = 1。假设服务端的序号为w(在半关闭状态，服务端可能又发送了一些数据)，服务端还必须重复发送上次的确认号 ack = u + 1。这时服务端就进入 LAST-ACK(最后确认)状态，等待 A 的确认。

- **第四次挥手**

客户端在收到服务端的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，客户端才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果服务端一收到客户端的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，服务端结束 TCP 连接的时间要早于客户端。